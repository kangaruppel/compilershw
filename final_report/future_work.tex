\section{Future Work}
There are three main tasks that we still want to do: analyze existing checkpointing systems to see if they fix the bugs we've detected, combine the results of our I/O based non-idempotency analysis with Alpaca to create a bug fixing tool, and add in fuzzing or symbolic execution to automatically verify the bug report.

In the Background Section we state that no prior work has addressed this type of bug, which is true, but some of the examples we found might still happen to get fixed by existing system. In the EasyLink receiver case study, for example, Alpaca \cite{alpaca} would probably fix the bug, since re-execution happens from the start of the task, but Ratchet \cite{ratchet} probably would not, since there is no WAR dependency and checkpoints are made in locations that split WAR dependencies. Based on preliminary analysis, other examples, such as MagInit, are not fixed by any prior system, but we want to do a more robust, complete comparison.

Extending our tool from bug detection to bug fixing should be a fairly simple next step. The main reason why these bugs are not going to be fixed by a system like Alpaca is that Alpaca does WAR analysis to detect variables that need to be saved, and it simply doesn't know about variables that are non-idempotent because of control dependence on I/O \cite{alpaca}. We can combine our analysis with Alpaca's to tell it to save the variables the I/O dependent variables as well, or we can instrument our pass to add empty reads of the I/O dependent variables, creating an ostensible WAR dependency and forcing Alpaca to track them.

The third remaining step is to find a better way to automatically validate the results of our tool. For the case studies presented in this report, the tool detected them, but we then closely examined the source code to derive the bug triggering traces and failure scenarios, spending significant time and effort. We could use the pass results, in particular the fact that we can determine the fairly small region where the bug is possible, as a guide for a fuzzer or symbolic execution tool, such as KLEE. Fuzzing can be impractical because of poor-code coverage and path explosion, but our pass information can significantly reduce the exploration space.